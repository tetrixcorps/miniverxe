---
// API Gateway - Routes all API requests to appropriate services
import type { APIRoute } from 'astro';

export const prerender = false;

export const GET: APIRoute = async ({ request, params }) => {
  const url = new URL(request.url);
  const hostname = request.headers.get('host') || '';
  const path = params.path || '';
  
  // Skip catch-all for specific frontend API routes that have dedicated route files
  // These routes are handled by specific files and should not go through the catch-all
  // In Astro, more specific routes take precedence, so if we reach here, the route file might not exist
  // But we should still let Astro handle it by returning a 404 that indicates the route should be handled elsewhere
  const specificRoutes = [
    'v2/auth/countries',  // Handled by src/pages/api/v2/auth/countries.ts
    'v1/joromi',  // JoRoMi API routes
    'v1/joromi/sessions',  // JoRoMi sessions
  ];
  
  // Check if this path matches any specific route pattern
  const isSpecificRoute = specificRoutes.some(route => path === route || path.startsWith(route + '/'));
  
  if (isSpecificRoute) {
    // This should never be reached if the specific route exists in the build
    // Return 404 to indicate the route should be handled by a specific file
    // If the specific route file exists, Astro will handle it before this catch-all
    console.warn(`‚ö†Ô∏è [CATCH-ALL] Specific route matched but handler not found: /api/${path}`);
    return new Response(JSON.stringify({
      error: "Route not found",
      path: `/api/${path}`,
      message: "This route should be handled by a specific route handler. If you see this, the route file may not be in the build output."
    }), {
      status: 404,
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  // HYBRID ROUTING SYSTEM: Handles both local development and production (Docker/droplet)
  // Determine environment and routing strategy
  const isLocalDev = hostname.includes('localhost') || hostname.includes('127.0.0.1');
  const isDocker = hostname.includes('tetrix-frontend') || process.env.TETRIX_BACKEND_URL || process.env.DATABASE_URL?.includes('tetrix-db');
  const backendUrl = process.env.TETRIX_BACKEND_URL || process.env.BACKEND_URL || 'http://tetrix-backend:3001';
  const externalProductionUrl = process.env.EXTERNAL_API_URL || 'https://tetrix-minimal-uzzxn.ondigitalocean.app';
  
  // Dashboard SSE streams need special handling - proxy to backend
  const isDashboardStream = path.startsWith('dashboard/') && path.endsWith('/stream');
  
  if (isDashboardStream) {
    if (isDocker && backendUrl) {
      const backendTarget = `${backendUrl}/api/${path}${url.search}`;
      console.log(`üîÑ [SSE-PROXY] Proxying SSE stream to backend: ${backendTarget}`);
      
      try {
        // Forward the request to backend SSE endpoint
        const response = await fetch(backendTarget, {
          method: 'GET',
          headers: {
            'Accept': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'User-Agent': request.headers.get('user-agent') || 'TetrixSSEProxy/1.0',
            // Forward user ID if present in query params
            ...(url.searchParams.get('userId') ? { 'X-User-ID': url.searchParams.get('userId')! } : {}),
          }
        });
        
        if (!response.ok || !response.body) {
          return new Response(JSON.stringify({
            error: 'SSE stream setup failed',
            status: response.status,
            statusText: response.statusText
          }), {
            status: response.status || 500,
            headers: { 'Content-Type': 'application/json' }
          });
        }
        
        // Return streaming response with proper SSE headers
        return new Response(response.body, {
          status: response.status,
          headers: {
            'Content-Type': 'text/event-stream',
            'Cache-Control': 'no-cache',
            'Connection': 'keep-alive',
            'X-Accel-Buffering': 'no',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization, X-User-ID',
          }
        });
      } catch (error) {
        console.error('‚ùå [SSE-PROXY] Error proxying SSE stream:', error);
        return new Response(JSON.stringify({
          error: 'SSE stream unavailable',
          message: error instanceof Error ? error.message : String(error)
        }), {
          status: 503,
          headers: { 'Content-Type': 'application/json' }
        });
      }
    }
    
    // Fallback for non-Docker environments
    return new Response(JSON.stringify({
      error: 'SSE streams require backend connection',
      message: 'Dashboard streams are only available when connected to backend service'
    }), {
      status: 503,
      headers: { 'Content-Type': 'application/json' }
    });
  }
  
  // Routes that should be handled by specific Astro API handlers or proxied
  const authRoutes = path.includes('v2/2fa/') || path.includes('v2/industry-auth/') || path.includes('dashboards/');
  
  if (authRoutes) {
    // STRATEGY 1: Local Development - Let Astro API route handlers take precedence
    if (isLocalDev && !isDocker) {
      console.log(`üìù [AUTH-PROXY] Local dev detected - allowing Astro route handler for ${path}`);
      return new Response(JSON.stringify({ 
        error: 'Not found',
        message: 'This route should be handled by a specific Astro API handler',
        path: `/api/${path}`
      }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
    // STRATEGY 2: Docker/Production - Proxy to internal backend service
    if (isDocker && backendUrl) {
      const backendTarget = `${backendUrl}/api/${path}${url.search}`;
      console.log(`üîÑ [AUTH-PROXY] Docker/production detected - proxying to backend: ${backendTarget}`);
      
      try {
        const response = await fetch(backendTarget, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            'User-Agent': request.headers.get('user-agent') || 'TetrixAuthProxy/1.0',
            'Accept': request.headers.get('accept') || 'application/json',
          }
        });
        
        const data = await response.text();
        
        return new Response(data, {
          status: response.status,
          headers: {
            'Content-Type': response.headers.get('content-type') || 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          }
        });
      } catch (error) {
        console.error('‚ùå [AUTH-PROXY] Error proxying to backend service:', error);
        // Fallback: Try external production URL as last resort
        console.log(`üîÑ [AUTH-PROXY] Fallback: Trying external production URL`);
        const fallbackUrl = `${externalProductionUrl}/api/${path}${url.search}`;
        try {
          const fallbackResponse = await fetch(fallbackUrl, {
            method: 'GET',
            headers: {
              'Content-Type': 'application/json',
              'User-Agent': request.headers.get('user-agent') || 'TetrixAuthProxy/1.0',
            }
          });
          const fallbackData = await fallbackResponse.text();
          return new Response(fallbackData, {
            status: fallbackResponse.status,
            headers: {
              'Content-Type': fallbackResponse.headers.get('content-type') || 'application/json',
              'Access-Control-Allow-Origin': '*',
            }
          });
        } catch (fallbackError) {
          return new Response(JSON.stringify({ 
            error: 'Authentication service unavailable',
            message: 'Could not connect to backend service or external API',
            details: error instanceof Error ? error.message : String(error)
          }), {
            status: 503,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }
    }
    
    // STRATEGY 3: Fallback - External production URL (only if explicitly configured)
    const externalUrl = `${externalProductionUrl}/api/${path}${url.search}`;
    console.log(`üîÑ [AUTH-PROXY] Using external production URL: ${externalUrl}`);
    
    try {
      const response = await fetch(externalUrl, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': request.headers.get('user-agent') || 'TetrixAuthProxy/1.0',
          'Accept': request.headers.get('accept') || 'application/json',
        }
      });
      
      const data = await response.text();
      
      return new Response(data, {
        status: response.status,
        headers: {
          'Content-Type': response.headers.get('content-type') || 'application/json',
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        }
      });
    } catch (error) {
      console.error('‚ùå [AUTH-PROXY] Error proxying to external URL:', error);
      return new Response(JSON.stringify({ 
        error: 'Authentication service unavailable',
        message: 'Could not connect to authentication service',
        details: error instanceof Error ? error.message : String(error)
      }), {
        status: 503,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
  
  // Route based on subdomain
  if (hostname.startsWith('api.')) {
    // API Gateway routing
    return new Response(JSON.stringify({
      service: 'TETRIX API Gateway',
      subdomain: 'api',
      path: path,
      status: 'operational',
      timestamp: new Date().toISOString(),
      endpoints: {
        '/health': 'Health check endpoint',
        '/voice': 'Voice API services',
        '/messaging': 'Messaging services',
        '/auth': 'Authentication services',
        '/projects': 'Project management',
        '/users': 'User management'
      }
    }), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization'
      }
    });
  }
  
  if (hostname.startsWith('iot.')) {
    // IoT Gateway routing
    return new Response(JSON.stringify({
      service: 'TETRIX IoT Gateway',
      subdomain: 'iot',
      path: path,
      status: 'operational',
      timestamp: new Date().toISOString(),
      endpoints: {
        '/devices': 'Device management',
        '/telemetry': 'Telemetry data',
        '/fleet': 'Fleet management',
        '/analytics': 'IoT analytics',
        '/alerts': 'Alert management'
      }
    }), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization'
      }
    });
  }
  
  if (hostname.startsWith('vpn.')) {
    // VPN Gateway routing
    return new Response(JSON.stringify({
      service: 'TETRIX VPN Gateway',
      subdomain: 'vpn',
      path: path,
      status: 'operational',
      timestamp: new Date().toISOString(),
      endpoints: {
        '/status': 'VPN status',
        '/config': 'VPN configuration',
        '/users': 'VPN user management',
        '/logs': 'Connection logs',
        '/security': 'Security settings'
      }
    }), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type, Authorization'
      }
    });
  }
  
  // Default API response
  return new Response(JSON.stringify({
    service: 'TETRIX Platform',
    status: 'operational',
    timestamp: new Date().toISOString(),
    message: 'Welcome to TETRIX API Gateway'
  }), {
    status: 200,
    headers: {
      'Content-Type': 'application/json',
      'Access-Control-Allow-Origin': '*'
    }
  });
};

export const POST: APIRoute = async ({ request, params }) => {
  const url = new URL(request.url);
  const hostname = request.headers.get('host') || '';
  const path = params.path || '';
  
  // HYBRID ROUTING SYSTEM: Handles both local development and production (Docker/droplet)
  // Determine environment and routing strategy
  const isLocalDev = hostname.includes('localhost') || hostname.includes('127.0.0.1');
  const isDocker = hostname.includes('tetrix-frontend') || process.env.TETRIX_BACKEND_URL || process.env.DATABASE_URL?.includes('tetrix-db');
  const backendUrl = process.env.TETRIX_BACKEND_URL || process.env.BACKEND_URL || 'http://tetrix-backend:3001';
  const externalProductionUrl = process.env.EXTERNAL_API_URL || 'https://tetrix-minimal-uzzxn.ondigitalocean.app';
  
  // Routes that should be handled by specific Astro API handlers or proxied
  const authRoutes = path.includes('v2/2fa/') || path.includes('v2/industry-auth/') || path.includes('dashboards/');
  
  if (authRoutes) {
    // STRATEGY 1: Local Development - Let Astro API route handlers take precedence
    if (isLocalDev && !isDocker) {
      console.log(`üìù [AUTH-PROXY] Local dev detected - allowing Astro route handler for ${path}`);
      return new Response(JSON.stringify({ 
        error: 'Not found',
        message: 'This route should be handled by a specific Astro API handler',
        path: `/api/${path}`
      }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' }
      });
    }
    
    // STRATEGY 2: Docker/Production - Proxy to internal backend service
    if (isDocker && backendUrl) {
      const backendTarget = `${backendUrl}/api/${path}${url.search}`;
      console.log(`üîÑ [AUTH-PROXY] Docker/production detected - proxying to backend: ${backendTarget}`);
      
      try {
        // Get the request body for POST requests
        const body = await request.text();
        
        const response = await fetch(backendTarget, {
          method: 'POST',
          headers: {
            'Content-Type': request.headers.get('content-type') || 'application/json',
            'User-Agent': request.headers.get('user-agent') || 'TetrixAuthProxy/1.0',
            'Accept': request.headers.get('accept') || 'application/json',
          },
          body: body
        });
        
        const data = await response.text();
        
        return new Response(data, {
          status: response.status,
          headers: {
            'Content-Type': response.headers.get('content-type') || 'application/json',
            'Access-Control-Allow-Origin': '*',
            'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
            'Access-Control-Allow-Headers': 'Content-Type, Authorization',
          }
        });
      } catch (error) {
        console.error('‚ùå [AUTH-PROXY] Error proxying to backend service:', error);
        // Fallback: Try external production URL as last resort
        console.log(`üîÑ [AUTH-PROXY] Fallback: Trying external production URL`);
        const fallbackUrl = `${externalProductionUrl}/api/${path}${url.search}`;
        const body = await request.text();
        try {
          const fallbackResponse = await fetch(fallbackUrl, {
            method: 'POST',
            headers: {
              'Content-Type': request.headers.get('content-type') || 'application/json',
              'User-Agent': request.headers.get('user-agent') || 'TetrixAuthProxy/1.0',
            },
            body: body
          });
          const fallbackData = await fallbackResponse.text();
          return new Response(fallbackData, {
            status: fallbackResponse.status,
            headers: {
              'Content-Type': fallbackResponse.headers.get('content-type') || 'application/json',
              'Access-Control-Allow-Origin': '*',
            }
          });
        } catch (fallbackError) {
          return new Response(JSON.stringify({ 
            error: 'Authentication service unavailable',
            message: 'Could not connect to backend service or external API',
            details: error instanceof Error ? error.message : String(error)
          }), {
            status: 503,
            headers: { 'Content-Type': 'application/json' }
          });
        }
      }
    }
    
    // STRATEGY 3: Fallback - External production URL (only if explicitly configured)
    const externalUrl = `${externalProductionUrl}/api/${path}${url.search}`;
    console.log(`üîÑ [AUTH-PROXY] Using external production URL: ${externalUrl}`);
    
    try {
      // Get the request body for POST requests
      const body = await request.text();
      
      const response = await fetch(externalUrl, {
        method: 'POST',
        headers: {
          'Content-Type': request.headers.get('content-type') || 'application/json',
          'User-Agent': request.headers.get('user-agent') || 'TetrixAuthProxy/1.0',
          'Accept': request.headers.get('accept') || 'application/json',
        },
        body: body
      });
      
      const data = await response.text();
      
      return new Response(data, {
        status: response.status,
        headers: {
          'Content-Type': response.headers.get('content-type') || 'application/json',
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization',
        }
      });
    } catch (error) {
      console.error('‚ùå [AUTH-PROXY] Error proxying to external URL:', error);
      return new Response(JSON.stringify({ 
        error: 'Authentication service unavailable',
        message: 'Could not connect to authentication service',
        details: error instanceof Error ? error.message : String(error)
      }), {
        status: 503,
        headers: { 'Content-Type': 'application/json' }
      });
    }
  }
  
  // Handle voice webhooks specifically
  if (path === 'voice/webhook') {
    try {
      const body = await request.json();
      const { event_type, data } = body;
      
      console.log('Voice webhook received:', {
        event_type,
        call_control_id: data?.call_control_id,
        from: data?.from,
        to: data?.to,
        timestamp: new Date().toISOString()
      });

      let twiMLResponse = '';

      // Handle different event types
      switch (event_type) {
        case 'call.initiated':
        case 'call.answered':
          // Generate greeting with menu
          twiMLResponse = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Welcome to TETRIX Enterprise Solutions. Press 1 for sales, 2 for support, 3 for billing, or 0 to speak with an operator.</Say>
  <Gather numDigits="1" action="${process.env.WEBHOOK_BASE_URL || 'https://tetrixcorp.com'}/api/voice/webhook" method="POST" timeout="10">
    <Say voice="alice">Please make your selection.</Say>
  </Gather>
  <Say voice="alice">We didn't receive any input. Please call back later. Goodbye.</Say>
  <Hangup/>
</Response>`;
          break;
        case 'call.gather.ended':
          // Handle DTMF input
          const dtmf = data?.digits || data?.dtmf;
          if (dtmf) {
            const webhookUrl = process.env.WEBHOOK_BASE_URL || 'https://tetrixcorp.com';
            
            switch (dtmf) {
              case '1': // Sales
                twiMLResponse = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Thank you for your interest in our sales department. Please hold while we connect you to a sales representative.</Say>
  <Dial timeout="30" record="record-from-answer">
    <Number>+1-888-804-6762</Number>
  </Dial>
  <Say voice="alice">The call could not be completed. Please try again later.</Say>
  <Hangup/>
</Response>`;
                break;
              case '2': // Support
                twiMLResponse = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">You have reached our technical support team. Please hold while we connect you to a support specialist.</Say>
  <Dial timeout="30" record="record-from-answer">
    <Number>+1-800-596-3057</Number>
  </Dial>
  <Say voice="alice">The call could not be completed. Please try again later.</Say>
  <Hangup/>
</Response>`;
                break;
              case '3': // Billing
                twiMLResponse = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">You have reached our billing department. Please hold while we connect you to a billing specialist.</Say>
  <Dial timeout="30" record="record-from-answer">
    <Number>+1-888-804-6762</Number>
  </Dial>
  <Say voice="alice">The call could not be completed. Please try again later.</Say>
  <Hangup/>
</Response>`;
                break;
              case '0': // Operator
                twiMLResponse = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Please hold while we connect you to an operator.</Say>
  <Dial timeout="30" record="record-from-answer">
    <Number>+1-800-596-3057</Number>
  </Dial>
  <Say voice="alice">The call could not be completed. Please try again later.</Say>
  <Hangup/>
</Response>`;
                break;
              default: // Invalid
                twiMLResponse = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Invalid selection. Please try again.</Say>
  <Redirect>${webhookUrl}/api/voice/webhook</Redirect>
</Response>`;
            }
          } else {
            twiMLResponse = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Welcome to TETRIX Enterprise Solutions. Press 1 for sales, 2 for support, 3 for billing, or 0 to speak with an operator.</Say>
  <Gather numDigits="1" action="${process.env.WEBHOOK_BASE_URL || 'https://tetrixcorp.com'}/api/voice/webhook" method="POST" timeout="10">
    <Say voice="alice">Please make your selection.</Say>
  </Gather>
  <Say voice="alice">We didn't receive any input. Please call back later. Goodbye.</Say>
  <Hangup/>
</Response>`;
          }
          break;
        case 'call.hangup':
          // Call ended
          twiMLResponse = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Hangup/>
</Response>`;
          break;
        default:
          console.log('Unhandled voice event:', event_type);
          twiMLResponse = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">Welcome to TETRIX Enterprise Solutions. Press 1 for sales, 2 for support, 3 for billing, or 0 to speak with an operator.</Say>
  <Gather numDigits="1" action="${process.env.WEBHOOK_BASE_URL || 'https://tetrixcorp.com'}/api/voice/webhook" method="POST" timeout="10">
    <Say voice="alice">Please make your selection.</Say>
  </Gather>
  <Say voice="alice">We didn't receive any input. Please call back later. Goodbye.</Say>
  <Hangup/>
</Response>`;
      }

      return new Response(twiMLResponse, {
        status: 200,
        headers: {
          'Content-Type': 'text/xml; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'X-Content-Type-Options': 'nosniff'
        }
      });

    } catch (error) {
      console.error('Voice webhook processing failed:', error);
      
      // Always return TwiML for voice webhooks
      const errorTwiML = `<?xml version="1.0" encoding="UTF-8"?>
<Response>
  <Say voice="alice">We're experiencing technical difficulties. Please try again later.</Say>
  <Hangup/>
</Response>`;
      
      return new Response(errorTwiML, {
        status: 200, // Return 200 to avoid Telnyx retries
        headers: {
          'Content-Type': 'text/xml; charset=utf-8',
          'Cache-Control': 'no-cache, no-store, must-revalidate',
          'X-Content-Type-Options': 'nosniff'
        }
      });
    }
  }
  
  // Handle POST requests based on subdomain
  if (hostname.startsWith('api.')) {
    // Process API requests
    return new Response(JSON.stringify({
      service: 'TETRIX API Gateway',
      method: 'POST',
      subdomain: 'api',
      path: path,
      status: 'processed',
      timestamp: new Date().toISOString()
    }), {
      status: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*'
      }
    });
  }
  
  return new Response(JSON.stringify({
    error: 'Method not supported',
    status: 405
  }), {
    status: 405,
    headers: {
      'Content-Type': 'application/json'
    }
  });
};

export const OPTIONS: APIRoute = async ({ request }) => {
  return new Response(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      'Access-Control-Max-Age': '86400'
    }
  });
};
